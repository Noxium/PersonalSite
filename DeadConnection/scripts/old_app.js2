let app;
let player;
let sceneObjectBodies = [];
let Engine = Matter.Engine;
let World = Matter.World;
let Bodies = Matter.Bodies;
let Body = Matter.Body;
let keyState = {};

let engine = Engine.create();

const texture = PIXI.Texture;
const sprite = PIXI.Sprite;
const WIDTH = 1200;
const HEIGHT = 600;
const CHUNK_SIZE = 32;
//const BLOCK_SIZE = 64;
const BLOCK_SIZE = 100;
const WORLD_WIDTH = 50;
const WORLD_HEIGHT = 30;
const SURFACE_Z = 5;
const PLAYER_SPEED = BLOCK_SIZE/15;
//const PLAYER_WIDTH = BLOCK_SIZE-5;
//const PLAYER_HEIGHT = BLOCK_SIZE-5;
const PLAYER_WIDTH = 128;
const PLAYER_HEIGHT = 64;
const PLAYER_HP = 100;
const JUMP_HEIGHT = 9;
const world_blocks = new PIXI.Container()
const sceneObjects = [];

window.onload = function() {
  app = new PIXI.Application({ 
    backgroundColor: 0x10A0C0,
    antialias: false,
    width: 1200,
    height: 600,
  });

  document.body.appendChild(app.view);
  PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;

  app.loader.baseUrl = "assets";
  app.loader
    .add("player", "robot_3.png")
    .add("r_base", "robot/base.png")
    .add("r_tire", "robot/tire.png")
    .add("drill", "drill.png")
    .add("dirt", "dirt_3.png")
    .add("grass", "grass_3.png");
  app.loader.onProgress.add(showProgress);
  app.loader.onComplete.add(doneLoading);
  app.loader.load();
}

function showProgress(e) {
  //console.log(e.progress);
}

function doneLoading() {
  app.stage.addChild(world_blocks);

  //player = new Player(app.screen.width/2, app.screen.height/2, PLAYER_WIDTH, PLAYER_HEIGHT, app.loader.resources["player"].texture, physicsBody, "player", 100, 5);
  player = new Player(app.screen.width/2, app.screen.height/2);

  let grass = new Block(BLOCK_SIZE, SURFACE_Z * BLOCK_SIZE - BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, app.loader.resources["grass"].texture, "grass", 30);
  app.stage.addChild(grass);
  createObjectFromSprite(grass, false, "grass");

  for(let i = 0; i < WORLD_HEIGHT; i++) {
    for(let j = -WORLD_WIDTH; j < WORLD_WIDTH; j++) {
      if(i == 0){
        let grass = new Block(j * BLOCK_SIZE, (i + SURFACE_Z) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, app.loader.resources["grass"].texture, "grass", 30);
        app.stage.addChild(grass);
        createObjectFromSprite(grass, false, "grass");
    } else {
        let dirt = new Block(j * BLOCK_SIZE, (i + SURFACE_Z) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, app.loader.resources["dirt"].texture, "dirt", 30);
        app.stage.addChild(dirt);
        createObjectFromSprite(dirt, false, "dirt");
      }
    }
  }

  window.addEventListener('keydown',function(e){
      keyState[e.keyCode || e.which] = true;
      //console.log(e.keyCode + " " + e.key);
  },true);
  window.addEventListener('keyup',function(e){
      keyState[e.keyCode || e.which] = false;
  },true);

  //TODO this is awful
  sceneObjects.forEach(object => {
    sceneObjectBodies.push(object.body);
  });


  Engine.run(engine);
  app.ticker.add(gameLoop);
}

function createObjectFromSprite(sprite, gravity_enabled=true, name='default') {
  const imageBody = Bodies.rectangle(
    sprite.x,
    sprite.y,
    sprite.width,
    sprite.height,
    {
      isStatic: !gravity_enabled,
      restitution: 0.0,  // prevent bouncing
      inertia: Infinity, // prevent rotation
      world_type: name,
      collisions_down: 0,
    }
  );
  World.addBody(engine.world, imageBody);

  sceneObjects.push({
    body: imageBody,
    sprite: sprite,
  });
}

function createObject(image, x, y, width, height, gravity_enabled=true, type='default') {
  const imageBody = Bodies.rectangle(
    x,
    y,
    width,
    height,
    {
      isStatic: !gravity_enabled,
      restitution: 0.0,  // prevent bouncing
      inertia: Infinity, // prevent rotation
      world_type: type,
      collisions_down: 0,
    }
  );

  World.addBody(engine.world, imageBody);

  const imageTex = new texture.from(image);
  const imageSprite = new sprite(imageTex);
  imageSprite.width = width;
  imageSprite.height = height;
  imageSprite.position;
  imageSprite.anchor.set(0.5, 0.5);
  app.stage.addChild(imageSprite);

  sceneObjects.push({
    body: imageBody,
    sprite: imageSprite,
  });
}

sprint_speed = 1;

Matter.Events.on(engine, 'collisionStart', function(event) {
  event.pairs.forEach(function(obj) {
    let player, floor = null;
    if(obj.bodyA.world_type == 'player') {
      player = obj.bodyA;
      floor = obj.bodyB;
    } else if(obj.bodyB.world_type == 'player') {
      player = obj.bodyB;
      floor = obj.bodyA;
    }
    if(player != null && floor != null) {
      if(floor.position.y > player.position.y) {
        player.collisions_down++;
      }
    }
  });
});

Matter.Events.on(engine, 'collisionEnd', function(event) {
  event.pairs.forEach(function(obj) {
    let player, floor = null;
    if(obj.bodyA.world_type == 'player') {
      player = obj.bodyA;
      floor = obj.bodyB;
    } else if(obj.bodyB.world_type == 'player') {
      player = obj.bodyB;
      floor = obj.bodyA;
    }
    if(player != null && floor != null) {
      if(floor.position.y > player.position.y) {
        player.collisions_down--;
      }
    }
  });
});

function gameLoop(delta) {
  sceneObjects.forEach(object => {
    if(object.sprite.type == 'player') {
      player = object.body;
      if(keyState[16] || keyState[17]) {
        // shift or ctrl
        sprint_speed = 1.5
      } else {
        sprint_speed = 1;
      }
      if (keyState[65]){
        // a
          Body.setVelocity(player, {x: -PLAYER_SPEED * sprint_speed, y: player.velocity.y});
        if(object.sprite.scale.x > 0) {
          object.sprite.scale.x *= -1;
        }
      } else {
        if(player.velocity.x < 0) {
          if(player.velocity.x > -0.0001) {
            Body.setVelocity(player, {x: 0, y: player.velocity.y});
          } else {
            Body.setVelocity(player, {x: player.velocity.x/1.07, y: player.velocity.y});
          }
        }
      }
      if (keyState[68]){
        // d
        //console.log(object.sprite.status());
        Body.setVelocity(player, {x: PLAYER_SPEED * sprint_speed, y: player.velocity.y});
        if(object.sprite.scale.x < 0) {
          object.sprite.scale.x *= -1;
        }
      } else {
        if(player.velocity.x > 0) {
          if(player.velocity.x < 0.0001) {
            Body.setVelocity(player, {x: 0, y: player.velocity.y});
          } else {
            Body.setVelocity(player, {x: player.velocity.x/1.07, y: player.velocity.y});
          }
        }
      }
      if (keyState[87]){
        // w
        if(player.collisions_down > 0) {
          Body.setVelocity(player, {x: player.velocity.x, y: -JUMP_HEIGHT});
        }
      } else if (keyState[83]){
        //console.log(sceneObjects);
        //console.log(sceneObjectBodies);
        closestBlock = raycast(sceneObjectBodies, player.position, {x: player.position.x, y: player.position.y + BLOCK_SIZE})[0];
        //console.log(closestBlock);
        deltaX = player.position.x - closestBlock.body.position.x;
        if(Math.abs(deltaX) < 1) {
          Body.setPosition(player, {x: closestBlock.body.position.x, y: player.position.y});
          Body.setVelocity(player, {x: 0, y: 0});
          console.log("Hello");
          app.stage.removeChild(closestBlock);
        } else if(player.position.x < closestBlock.body.position.x) {
          Body.setVelocity(player, {x: -deltaX/5, y: player.velocity.y});
        } else {
          Body.setVelocity(player, {x: -deltaX/5, y: player.velocity.y});
        }
      }
      app.stage.pivot.x = player.position.x - (WIDTH / 2);
      app.stage.pivot.y = player.position.y - (HEIGHT / 2);
    }
    object.sprite.position = object.body.position;
    object.sprite.rotation = object.body.angle;
  });
}

